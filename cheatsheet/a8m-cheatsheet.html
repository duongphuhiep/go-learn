<!DOCTYPE html>
<html>
<head>
<title>a8m-cheatsheet.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 8px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 10px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}
body, code {
    font-size: 70%;
    line-height: 100%;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="go-cheat-sheet">Go Cheat Sheet</h1>
<h1 id="index">Index</h1>
<ol>
<li><a href="#basic-syntax">Basic Syntax</a></li>
<li><a href="#operators">Operators</a>
<ul>
<li><a href="#arithmetic">Arithmetic</a></li>
<li><a href="#comparison">Comparison</a></li>
<li><a href="#logical">Logical</a></li>
<li><a href="#other">Other</a></li>
</ul>
</li>
<li><a href="#declarations">Declarations</a></li>
<li><a href="#functions">Functions</a>
<ul>
<li><a href="#functions-as-values-and-closures">Functions as values and closures</a></li>
<li><a href="#variadic-functions">Variadic Functions</a></li>
</ul>
</li>
<li><a href="#built-in-types">Built-in Types</a></li>
<li><a href="#type-conversions">Type Conversions</a></li>
<li><a href="#packages">Packages</a></li>
<li><a href="#control-structures">Control structures</a>
<ul>
<li><a href="#if">If</a></li>
<li><a href="#loops">Loops</a></li>
<li><a href="#switch">Switch</a></li>
</ul>
</li>
<li><a href="#arrays-slices-ranges">Arrays, Slices, Ranges</a>
<ul>
<li><a href="#arrays">Arrays</a></li>
<li><a href="#slices">Slices</a></li>
<li><a href="#operations-on-arrays-and-slices">Operations on Arrays and Slices</a></li>
</ul>
</li>
<li><a href="#maps">Maps</a></li>
<li><a href="#structs">Structs</a></li>
<li><a href="#pointers">Pointers</a></li>
<li><a href="#interfaces">Interfaces</a></li>
<li><a href="#embedding">Embedding</a></li>
<li><a href="#errors">Errors</a></li>
<li><a href="#concurrency">Concurrency</a>
<ul>
<li><a href="#goroutines">Goroutines</a></li>
<li><a href="#channels">Channels</a></li>
<li><a href="#channel-axioms">Channel Axioms</a></li>
</ul>
</li>
<li><a href="#printing">Printing</a></li>
<li><a href="#reflection">Reflection</a>
<ul>
<li><a href="#type-switch">Type Switch</a></li>
<li><a href="https://github.com/a8m/reflect-examples">Examples</a></li>
</ul>
</li>
<li><a href="#snippets">Snippets</a>
<ul>
<li><a href="#files-embedding">Files Embedding</a></li>
<li><a href="#http-server">HTTP Server</a></li>
</ul>
</li>
</ol>
<h2 id="credits">Credits</h2>
<p>Most example code taken from <a href="http://tour.golang.org/">A Tour of Go</a>, which is an excellent introduction to Go.
If you're new to Go, do that tour. Seriously.</p>
<h2 id="go-in-a-nutshell">Go in a Nutshell</h2>
<ul>
<li>Imperative language</li>
<li>Statically typed</li>
<li>Syntax tokens similar to C (but less parentheses and no semicolons) and the structure to Oberon-2</li>
<li>Compiles to native code (no JVM)</li>
<li>No classes, but structs with methods</li>
<li>Interfaces</li>
<li>No implementation inheritance. There's <a href="http://golang.org/doc/effective%5Fgo.html#embedding">type embedding</a>, though.</li>
<li>Functions are first class citizens</li>
<li>Functions can return multiple values</li>
<li>Has closures</li>
<li>Pointers, but not pointer arithmetic</li>
<li>Built-in concurrency primitives: Goroutines and Channels</li>
</ul>
<h1 id="basic-syntax">Basic Syntax</h1>
<h2 id="hello-world">Hello World</h2>
<p>File <code>hello.go</code>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    fmt.Println(<span class="hljs-string">"Hello Go"</span>)
}
</div></code></pre>
<p><code>$ go run hello.go</code></p>
<h2 id="operators">Operators</h2>
<h3 id="arithmetic">Arithmetic</h3>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>+</code></td>
<td>addition</td>
</tr>
<tr>
<td><code>-</code></td>
<td>subtraction</td>
</tr>
<tr>
<td><code>*</code></td>
<td>multiplication</td>
</tr>
<tr>
<td><code>/</code></td>
<td>quotient</td>
</tr>
<tr>
<td><code>%</code></td>
<td>remainder</td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>bitwise and</td>
</tr>
<tr>
<td><code>\|</code></td>
<td>bitwise or</td>
</tr>
<tr>
<td><code>^</code></td>
<td>bitwise xor</td>
</tr>
<tr>
<td><code>&amp;^</code></td>
<td>bit clear (and not)</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>left shift</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>right shift</td>
</tr>
</tbody>
</table>
<h3 id="comparison">Comparison</h3>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>==</code></td>
<td>equal</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>not equal</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>less than</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>less than or equal</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>greater than</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>greater than or equal</td>
</tr>
</tbody>
</table>
<h3 id="logical">Logical</h3>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;&amp;</code></td>
<td>logical and</td>
</tr>
<tr>
<td><code>\|\|</code></td>
<td>logical or</td>
</tr>
<tr>
<td><code>!</code></td>
<td>logical not</td>
</tr>
</tbody>
</table>
<h3 id="other">Other</h3>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;</code></td>
<td>address of / create pointer</td>
</tr>
<tr>
<td><code>*</code></td>
<td>dereference pointer</td>
</tr>
<tr>
<td><code>&lt;-</code></td>
<td>send / receive operator (see 'Channels' below)</td>
</tr>
</tbody>
</table>
<h2 id="declarations">Declarations</h2>
<p>Type goes after identifier!</p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> foo <span class="hljs-keyword">int</span> <span class="hljs-comment">// declaration without initialization</span>
<span class="hljs-keyword">var</span> foo <span class="hljs-keyword">int</span> = <span class="hljs-number">42</span> <span class="hljs-comment">// declaration with initialization</span>
<span class="hljs-keyword">var</span> foo, bar <span class="hljs-keyword">int</span> = <span class="hljs-number">42</span>, <span class="hljs-number">1302</span> <span class="hljs-comment">// declare and init multiple vars at once</span>
<span class="hljs-keyword">var</span> foo = <span class="hljs-number">42</span> <span class="hljs-comment">// type omitted, will be inferred</span>
foo := <span class="hljs-number">42</span> <span class="hljs-comment">// shorthand, only in func bodies, omit var keyword, type is always implicit</span>
<span class="hljs-keyword">const</span> constant = <span class="hljs-string">"This is a constant"</span>

<span class="hljs-comment">// iota can be used for incrementing numbers, starting from 0</span>
<span class="hljs-keyword">const</span> (
    _ = <span class="hljs-literal">iota</span>
    a
    b
    c = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-literal">iota</span>
    d
)
fmt.Println(a, b) <span class="hljs-comment">// 1 2 (0 is skipped)</span>
fmt.Println(c, d) <span class="hljs-comment">// 8 16 (2^3, 2^4)</span>
</div></code></pre>
<h2 id="functions">Functions</h2>
<pre class="hljs"><code><div><span class="hljs-comment">// a simple function</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">functionName</span><span class="hljs-params">()</span></span> {}

<span class="hljs-comment">// function with parameters (again, types go after identifiers)</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">functionName</span><span class="hljs-params">(param1 <span class="hljs-keyword">string</span>, param2 <span class="hljs-keyword">int</span>)</span></span> {}

<span class="hljs-comment">// multiple parameters of the same type</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">functionName</span><span class="hljs-params">(param1, param2 <span class="hljs-keyword">int</span>)</span></span> {}

<span class="hljs-comment">// return type declaration</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">functionName</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> {
    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>
}

<span class="hljs-comment">// Can return multiple values at once</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">returnMulti</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">string</span>)</span></span> {
    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>, <span class="hljs-string">"foobar"</span>
}
<span class="hljs-keyword">var</span> x, str = returnMulti()

<span class="hljs-comment">// Return multiple named results simply by return</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">returnMulti2</span><span class="hljs-params">()</span> <span class="hljs-params">(n <span class="hljs-keyword">int</span>, s <span class="hljs-keyword">string</span>)</span></span> {
    n = <span class="hljs-number">42</span>
    s = <span class="hljs-string">"foobar"</span>
    <span class="hljs-comment">// n and s will be returned</span>
    <span class="hljs-keyword">return</span>
}
<span class="hljs-keyword">var</span> x, str = returnMulti2()

</div></code></pre>
<h3 id="functions-as-values-and-closures">Functions As Values And Closures</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// assign a function to a name</span>
    add := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> {
        <span class="hljs-keyword">return</span> a + b
    }
    <span class="hljs-comment">// use the name to call the function</span>
    fmt.Println(add(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))
}

<span class="hljs-comment">// Closures, lexically scoped: Functions can access values that were</span>
<span class="hljs-comment">// in scope when defining the function</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scope</span><span class="hljs-params">()</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span>{
    outer_var := <span class="hljs-number">2</span>
    foo := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> { <span class="hljs-keyword">return</span> outer_var}
    <span class="hljs-keyword">return</span> foo
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">another_scope</span><span class="hljs-params">()</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span>{
    <span class="hljs-comment">// won't compile because outer_var and foo not defined in this scope</span>
    outer_var = <span class="hljs-number">444</span>
    <span class="hljs-keyword">return</span> foo
}


<span class="hljs-comment">// Closures</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">outer</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">func</span>()</span> <span class="hljs-title">int</span>, <span class="hljs-title">int</span>)</span> {
    outer_var := <span class="hljs-number">2</span>
    inner := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> {
        outer_var += <span class="hljs-number">99</span> <span class="hljs-comment">// outer_var from outer scope is mutated.</span>
        <span class="hljs-keyword">return</span> outer_var
    }
    inner()
    <span class="hljs-keyword">return</span> inner, outer_var <span class="hljs-comment">// return inner func and mutated outer_var 101</span>
}
</div></code></pre>
<h3 id="variadic-functions">Variadic Functions</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    fmt.Println(adder(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))     <span class="hljs-comment">// 6</span>
    fmt.Println(adder(<span class="hljs-number">9</span>, <span class="hljs-number">9</span>))    <span class="hljs-comment">// 18</span>

    nums := []<span class="hljs-keyword">int</span>{<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>}
    fmt.Println(adder(nums...))    <span class="hljs-comment">// 60</span>
}

<span class="hljs-comment">// By using ... before the type name of the last parameter you can indicate that it takes zero or more of those parameters.</span>
<span class="hljs-comment">// The function is invoked like any other function except we can pass as many arguments as we want.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">adder</span><span class="hljs-params">(args ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> {
    total := <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> args { <span class="hljs-comment">// Iterates over the arguments whatever the number.</span>
        total += v
    }
    <span class="hljs-keyword">return</span> total
}
</div></code></pre>
<h2 id="built-in-types">Built-in Types</h2>
<pre class="hljs"><code><div><span class="hljs-keyword">bool</span>

<span class="hljs-keyword">string</span>

<span class="hljs-keyword">int</span>  <span class="hljs-keyword">int8</span>  <span class="hljs-keyword">int16</span>  <span class="hljs-keyword">int32</span>  <span class="hljs-keyword">int64</span>
<span class="hljs-keyword">uint</span> <span class="hljs-keyword">uint8</span> <span class="hljs-keyword">uint16</span> <span class="hljs-keyword">uint32</span> <span class="hljs-keyword">uint64</span> <span class="hljs-keyword">uintptr</span>

<span class="hljs-keyword">byte</span> <span class="hljs-comment">// alias for uint8</span>

<span class="hljs-keyword">rune</span> <span class="hljs-comment">// alias for int32 ~= a character (Unicode code point) - very Viking</span>

<span class="hljs-keyword">float32</span> <span class="hljs-keyword">float64</span>

<span class="hljs-keyword">complex64</span> <span class="hljs-keyword">complex128</span>
</div></code></pre>
<p>All Go's predeclared identifiers are defined in the <a href="https://golang.org/pkg/builtin/">builtin</a> package.</p>
<h2 id="type-conversions">Type Conversions</h2>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> i <span class="hljs-keyword">int</span> = <span class="hljs-number">42</span>
<span class="hljs-keyword">var</span> f <span class="hljs-keyword">float64</span> = <span class="hljs-keyword">float64</span>(i)
<span class="hljs-keyword">var</span> u <span class="hljs-keyword">uint</span> = <span class="hljs-keyword">uint</span>(f)

<span class="hljs-comment">// alternative syntax</span>
i := <span class="hljs-number">42</span>
f := <span class="hljs-keyword">float64</span>(i)
u := <span class="hljs-keyword">uint</span>(f)
</div></code></pre>
<h2 id="packages">Packages</h2>
<ul>
<li>Package declaration at top of every source file</li>
<li>Executables are in package <code>main</code></li>
<li>Convention: package name == last name of import path (import path <code>math/rand</code> =&gt; package <code>rand</code>)</li>
<li>Upper case identifier: exported (visible from other packages)</li>
<li>Lower case identifier: private (not visible from other packages)</li>
</ul>
<h2 id="control-structures">Control structures</h2>
<h3 id="if">If</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// Basic one</span>
    <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">10</span> {
        <span class="hljs-keyword">return</span> x
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> x == <span class="hljs-number">10</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> -x
    }

    <span class="hljs-comment">// You can put one statement before the condition</span>
    <span class="hljs-keyword">if</span> a := b + c; a &lt; <span class="hljs-number">42</span> {
        <span class="hljs-keyword">return</span> a
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> a - <span class="hljs-number">42</span>
    }

    <span class="hljs-comment">// Type assertion inside if</span>
    <span class="hljs-keyword">var</span> val <span class="hljs-keyword">interface</span>{} = <span class="hljs-string">"foo"</span>
    <span class="hljs-keyword">if</span> str, ok := val.(<span class="hljs-keyword">string</span>); ok {
        fmt.Println(str)
    }
}
</div></code></pre>
<h3 id="loops">Loops</h3>
<pre class="hljs"><code><div>    <span class="hljs-comment">// There's only `for`, no `while`, no `until`</span>
    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++ {
    }
    <span class="hljs-keyword">for</span> ; i &lt; <span class="hljs-number">10</span>;  { <span class="hljs-comment">// while - loop</span>
    }
    <span class="hljs-keyword">for</span> i &lt; <span class="hljs-number">10</span>  { <span class="hljs-comment">// you can omit semicolons if there is only a condition</span>
    }
    <span class="hljs-keyword">for</span> { <span class="hljs-comment">// you can omit the condition ~ while (true)</span>
    }
    
    <span class="hljs-comment">// use break/continue on current loop</span>
    <span class="hljs-comment">// use break/continue with label on outer loop</span>
here:
    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++ {
        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">3</span>; j++ {
            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> {
                <span class="hljs-keyword">continue</span> here
            }
            fmt.Println(j)
            <span class="hljs-keyword">if</span> j == <span class="hljs-number">2</span> {
                <span class="hljs-keyword">break</span>
            }
        }
    }

there:
    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++ {
        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">3</span>; j++ {
            <span class="hljs-keyword">if</span> j == <span class="hljs-number">1</span> {
                <span class="hljs-keyword">continue</span>
            }
            fmt.Println(j)
            <span class="hljs-keyword">if</span> j == <span class="hljs-number">2</span> {
                <span class="hljs-keyword">break</span> there
            }
        }
    }
</div></code></pre>
<h3 id="switch">Switch</h3>
<pre class="hljs"><code><div>    <span class="hljs-comment">// switch statement</span>
    <span class="hljs-keyword">switch</span> operatingSystem {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"darwin"</span>:
        fmt.Println(<span class="hljs-string">"Mac OS Hipster"</span>)
        <span class="hljs-comment">// cases break automatically, no fallthrough by default</span>
    <span class="hljs-keyword">case</span> <span class="hljs-string">"linux"</span>:
        fmt.Println(<span class="hljs-string">"Linux Geek"</span>)
    <span class="hljs-keyword">default</span>:
        <span class="hljs-comment">// Windows, BSD, ...</span>
        fmt.Println(<span class="hljs-string">"Other"</span>)
    }

    <span class="hljs-comment">// as with for and if, you can have an assignment statement before the switch value</span>
    <span class="hljs-keyword">switch</span> os := runtime.GOOS; os {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"darwin"</span>: ...
    }

    <span class="hljs-comment">// you can also make comparisons in switch cases</span>
    number := <span class="hljs-number">42</span>
    <span class="hljs-keyword">switch</span> {
        <span class="hljs-keyword">case</span> number &lt; <span class="hljs-number">42</span>:
            fmt.Println(<span class="hljs-string">"Smaller"</span>)
        <span class="hljs-keyword">case</span> number == <span class="hljs-number">42</span>:
            fmt.Println(<span class="hljs-string">"Equal"</span>)
        <span class="hljs-keyword">case</span> number &gt; <span class="hljs-number">42</span>:
            fmt.Println(<span class="hljs-string">"Greater"</span>)
    }

    <span class="hljs-comment">// cases can be presented in comma-separated lists</span>
    <span class="hljs-keyword">var</span> char <span class="hljs-keyword">byte</span> = <span class="hljs-string">'?'</span>
    <span class="hljs-keyword">switch</span> char {
        <span class="hljs-keyword">case</span> <span class="hljs-string">' '</span>, <span class="hljs-string">'?'</span>, <span class="hljs-string">'&amp;'</span>, <span class="hljs-string">'='</span>, <span class="hljs-string">'#'</span>, <span class="hljs-string">'+'</span>, <span class="hljs-string">'%'</span>:
            fmt.Println(<span class="hljs-string">"Should escape"</span>)
    }
</div></code></pre>
<h2 id="arrays-slices-ranges">Arrays, Slices, Ranges</h2>
<h3 id="arrays">Arrays</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> a [<span class="hljs-number">10</span>]<span class="hljs-keyword">int</span> <span class="hljs-comment">// declare an int array with length 10. Array length is part of the type!</span>
a[<span class="hljs-number">3</span>] = <span class="hljs-number">42</span>     <span class="hljs-comment">// set elements</span>
i := a[<span class="hljs-number">3</span>]     <span class="hljs-comment">// read elements</span>

<span class="hljs-comment">// declare and initialize</span>
<span class="hljs-keyword">var</span> a = [<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>}
a := [<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>} <span class="hljs-comment">//shorthand</span>
a := [...]<span class="hljs-keyword">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>} <span class="hljs-comment">// elipsis -&gt; Compiler figures out array length</span>
</div></code></pre>
<h3 id="slices">Slices</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> a []<span class="hljs-keyword">int</span>                              <span class="hljs-comment">// declare a slice - similar to an array, but length is unspecified</span>
<span class="hljs-keyword">var</span> a = []<span class="hljs-keyword">int</span> {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>}               <span class="hljs-comment">// declare and initialize a slice (backed by the array given implicitly)</span>
a := []<span class="hljs-keyword">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>}                   <span class="hljs-comment">// shorthand</span>
chars := []<span class="hljs-keyword">string</span>{<span class="hljs-number">0</span>:<span class="hljs-string">"a"</span>, <span class="hljs-number">2</span>:<span class="hljs-string">"c"</span>, <span class="hljs-number">1</span>: <span class="hljs-string">"b"</span>}  <span class="hljs-comment">// ["a", "b", "c"]</span>

<span class="hljs-keyword">var</span> b = a[lo:hi]    <span class="hljs-comment">// creates a slice (view of the array) from index lo to hi-1</span>
<span class="hljs-keyword">var</span> b = a[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]        <span class="hljs-comment">// slice from index 1 to 3</span>
<span class="hljs-keyword">var</span> b = a[:<span class="hljs-number">3</span>]        <span class="hljs-comment">// missing low index implies 0</span>
<span class="hljs-keyword">var</span> b = a[<span class="hljs-number">3</span>:]        <span class="hljs-comment">// missing high index implies len(a)</span>
a =  <span class="hljs-built_in">append</span>(a,<span class="hljs-number">17</span>,<span class="hljs-number">3</span>)    <span class="hljs-comment">// append items to slice a</span>
c := <span class="hljs-built_in">append</span>(a,b...)    <span class="hljs-comment">// concatenate slices a and b</span>

<span class="hljs-comment">// create a slice with make</span>
a = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>)    <span class="hljs-comment">// first arg length, second capacity</span>
a = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">5</span>)    <span class="hljs-comment">// capacity is optional</span>

<span class="hljs-comment">// create a slice from an array</span>
x := [<span class="hljs-number">3</span>]<span class="hljs-keyword">string</span>{<span class="hljs-string">"Лайка"</span>, <span class="hljs-string">"Белка"</span>, <span class="hljs-string">"Стрелка"</span>}
s := x[:] <span class="hljs-comment">// a slice referencing the storage of x</span>
</div></code></pre>
<h3 id="operations-on-arrays-and-slices">Operations on Arrays and Slices</h3>
<p><code>len(a)</code> gives you the length of an array/a slice. It's a built-in function, not a attribute/method on the array.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// loop over an array/a slice</span>
<span class="hljs-keyword">for</span> i, e := <span class="hljs-keyword">range</span> a {
    <span class="hljs-comment">// i is the index, e the element</span>
}

<span class="hljs-comment">// if you only need e:</span>
<span class="hljs-keyword">for</span> _, e := <span class="hljs-keyword">range</span> a {
    <span class="hljs-comment">// e is the element</span>
}

<span class="hljs-comment">// ...and if you only need the index</span>
<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> a {
}

<span class="hljs-comment">// In Go pre-1.4, you'll get a compiler error if you're not using i and e.</span>
<span class="hljs-comment">// Go 1.4 introduced a variable-free form, so that you can do this</span>
<span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> time.Tick(time.Second) {
    <span class="hljs-comment">// do it once a sec</span>
}

</div></code></pre>
<h2 id="maps">Maps</h2>
<pre class="hljs"><code><div>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)
m[<span class="hljs-string">"key"</span>] = <span class="hljs-number">42</span>
fmt.Println(m[<span class="hljs-string">"key"</span>])

<span class="hljs-built_in">delete</span>(m, <span class="hljs-string">"key"</span>)

elem, ok := m[<span class="hljs-string">"key"</span>] <span class="hljs-comment">// test if key "key" is present and retrieve it, if so</span>

<span class="hljs-comment">// map literal</span>
<span class="hljs-keyword">var</span> m = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]Vertex{
    <span class="hljs-string">"Bell Labs"</span>: {<span class="hljs-number">40.68433</span>, <span class="hljs-number">-74.39967</span>},
    <span class="hljs-string">"Google"</span>:    {<span class="hljs-number">37.42202</span>, <span class="hljs-number">-122.08408</span>},
}

<span class="hljs-comment">// iterate over map content</span>
<span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> m {
}

</div></code></pre>
<h2 id="structs">Structs</h2>
<p>There are no classes, only structs. Structs can have methods.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// A struct is a type. It's also a collection of fields</span>

<span class="hljs-comment">// Declaration</span>
<span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> {
    X, Y <span class="hljs-keyword">int</span>
}

<span class="hljs-comment">// Creating</span>
<span class="hljs-keyword">var</span> v = Vertex{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>}
<span class="hljs-keyword">var</span> v = Vertex{X: <span class="hljs-number">1</span>, Y: <span class="hljs-number">2</span>} <span class="hljs-comment">// Creates a struct by defining values with keys</span>
<span class="hljs-keyword">var</span> v = []Vertex{{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>},{<span class="hljs-number">5</span>,<span class="hljs-number">2</span>},{<span class="hljs-number">5</span>,<span class="hljs-number">5</span>}} <span class="hljs-comment">// Initialize a slice of structs</span>

<span class="hljs-comment">// Accessing members</span>
v.X = <span class="hljs-number">4</span>

<span class="hljs-comment">// You can declare methods on structs. The struct you want to declare the</span>
<span class="hljs-comment">// method on (the receiving type) comes between the the func keyword and</span>
<span class="hljs-comment">// the method name. The struct is copied on each method call(!)</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Vertex)</span> <span class="hljs-title">Abs</span><span class="hljs-params">()</span> <span class="hljs-title">float64</span></span> {
    <span class="hljs-keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)
}

<span class="hljs-comment">// Call method</span>
v.Abs()

<span class="hljs-comment">// For mutating methods, you need to use a pointer (see below) to the Struct</span>
<span class="hljs-comment">// as the type. With this, the struct value is not copied for the method call.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Vertex)</span> <span class="hljs-title">add</span><span class="hljs-params">(n <span class="hljs-keyword">float64</span>)</span></span> {
    v.X += n
    v.Y += n
}

</div></code></pre>
<p><strong>Anonymous structs:</strong>
Cheaper and safer than using <code>map[string]interface{}</code>.</p>
<pre class="hljs"><code><div>point := <span class="hljs-keyword">struct</span> {
    X, Y <span class="hljs-keyword">int</span>
}{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>}
</div></code></pre>
<h2 id="pointers">Pointers</h2>
<pre class="hljs"><code><div>p := Vertex{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>}  <span class="hljs-comment">// p is a Vertex</span>
q := &amp;p            <span class="hljs-comment">// q is a pointer to a Vertex</span>
r := &amp;Vertex{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>} <span class="hljs-comment">// r is also a pointer to a Vertex</span>

<span class="hljs-comment">// The type of a pointer to a Vertex is *Vertex</span>

<span class="hljs-keyword">var</span> s *Vertex = <span class="hljs-built_in">new</span>(Vertex) <span class="hljs-comment">// new creates a pointer to a new struct instance</span>
</div></code></pre>
<h2 id="interfaces">Interfaces</h2>
<pre class="hljs"><code><div><span class="hljs-comment">// interface declaration</span>
<span class="hljs-keyword">type</span> Awesomizer <span class="hljs-keyword">interface</span> {
    Awesomize() <span class="hljs-keyword">string</span>
}

<span class="hljs-comment">// types do *not* declare to implement interfaces</span>
<span class="hljs-keyword">type</span> Foo <span class="hljs-keyword">struct</span> {}

<span class="hljs-comment">// instead, types implicitly satisfy an interface if they implement all required methods</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(foo Foo)</span> <span class="hljs-title">Awesomize</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Awesome!"</span>
}
</div></code></pre>
<h2 id="embedding">Embedding</h2>
<p>There is no subclassing in Go. Instead, there is interface and struct embedding.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// ReadWriter implementations must satisfy both Reader and Writer</span>
<span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">interface</span> {
    Reader
    Writer
}

<span class="hljs-comment">// Server exposes all the methods that Logger has</span>
<span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span> {
    Host <span class="hljs-keyword">string</span>
    Port <span class="hljs-keyword">int</span>
    *log.Logger
}

<span class="hljs-comment">// initialize the embedded type the usual way</span>
server := &amp;Server{<span class="hljs-string">"localhost"</span>, <span class="hljs-number">80</span>, log.New(...)}

<span class="hljs-comment">// methods implemented on the embedded struct are passed through</span>
server.Log(...) <span class="hljs-comment">// calls server.Logger.Log(...)</span>

<span class="hljs-comment">// the field name of the embedded type is its type name (in this case Logger)</span>
<span class="hljs-keyword">var</span> logger *log.Logger = server.Logger
</div></code></pre>
<h2 id="errors">Errors</h2>
<p>There is no exception handling. Instead, functions that might produce an error just declare an additional return value of type <a href="https://golang.org/pkg/builtin/#error"><code>error</code></a>. This is the <code>error</code> interface:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// The error built-in interface type is the conventional interface for representing an error condition,</span>
<span class="hljs-comment">// with the nil value representing no error.</span>
<span class="hljs-keyword">type</span> error <span class="hljs-keyword">interface</span> {
    Error() <span class="hljs-keyword">string</span>
}
</div></code></pre>
<p>Here's an example:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(x <span class="hljs-keyword">float64</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">float64</span>, error)</span></span> {
    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.New(<span class="hljs-string">"negative value"</span>)
    }
    <span class="hljs-keyword">return</span> math.Sqrt(x), <span class="hljs-literal">nil</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    val, err := sqrt(<span class="hljs-number">-1</span>)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        <span class="hljs-comment">// handle error</span>
        fmt.Println(err) <span class="hljs-comment">// negative value</span>
        <span class="hljs-keyword">return</span>
    }
    <span class="hljs-comment">// All is good, use `val`.</span>
    fmt.Println(val)
}
</div></code></pre>
<h1 id="concurrency">Concurrency</h1>
<h2 id="goroutines">Goroutines</h2>
<p>Goroutines are lightweight threads (managed by Go, not OS threads). <code>go f(a, b)</code> starts a new goroutine which runs <code>f</code> (given <code>f</code> is a function).</p>
<pre class="hljs"><code><div><span class="hljs-comment">// just a function (which can be later started as a goroutine)</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doStuff</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span></span> {
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-comment">// using a named function in a goroutine</span>
    <span class="hljs-keyword">go</span> doStuff(<span class="hljs-string">"foobar"</span>)

    <span class="hljs-comment">// using an anonymous inner function in a goroutine</span>
    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span></span> {
        <span class="hljs-comment">// function body goes here</span>
    }(<span class="hljs-number">42</span>)
}
</div></code></pre>
<h2 id="channels">Channels</h2>
<pre class="hljs"><code><div>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>) <span class="hljs-comment">// create a channel of type int</span>
ch &lt;- <span class="hljs-number">42</span>             <span class="hljs-comment">// Send a value to the channel ch.</span>
v := &lt;-ch            <span class="hljs-comment">// Receive a value from ch</span>

<span class="hljs-comment">// Non-buffered channels block. Read blocks when no value is available, write blocks until there is a read.</span>

<span class="hljs-comment">// Create a buffered channel. Writing to a buffered channels does not block if less than &lt;buffer size&gt; unread values have been written.</span>
ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">100</span>)

<span class="hljs-built_in">close</span>(ch) <span class="hljs-comment">// closes the channel (only sender should close)</span>

<span class="hljs-comment">// read from channel and test if it has been closed</span>
v, ok := &lt;-ch

<span class="hljs-comment">// if ok is false, channel has been closed</span>

<span class="hljs-comment">// Read from channel until it is closed</span>
<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> ch {
    fmt.Println(i)
}

<span class="hljs-comment">// select blocks on multiple channel operations, if one unblocks, the corresponding case is executed</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doStuff</span><span class="hljs-params">(channelOut, channelIn <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> {
    <span class="hljs-keyword">select</span> {
    <span class="hljs-keyword">case</span> channelOut &lt;- <span class="hljs-number">42</span>:
        fmt.Println(<span class="hljs-string">"We could write to channelOut!"</span>)
    <span class="hljs-keyword">case</span> x := &lt;- channelIn:
        fmt.Println(<span class="hljs-string">"We could read from channelIn"</span>)
    <span class="hljs-keyword">case</span> &lt;-time.After(time.Second * <span class="hljs-number">1</span>):
        fmt.Println(<span class="hljs-string">"timeout"</span>)
    }
}
</div></code></pre>
<h3 id="channel-axioms">Channel Axioms</h3>
<ul>
<li>
<p>A send to a nil channel blocks forever</p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> c <span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>
c &lt;- <span class="hljs-string">"Hello, World!"</span>
<span class="hljs-comment">// fatal error: all goroutines are asleep - deadlock!</span>
</div></code></pre>
</li>
<li>
<p>A receive from a nil channel blocks forever</p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> c <span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>
fmt.Println(&lt;-c)
<span class="hljs-comment">// fatal error: all goroutines are asleep - deadlock!</span>
</div></code></pre>
</li>
<li>
<p>A send to a closed channel panics</p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> c = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, <span class="hljs-number">1</span>)
c &lt;- <span class="hljs-string">"Hello, World!"</span>
<span class="hljs-built_in">close</span>(c)
c &lt;- <span class="hljs-string">"Hello, Panic!"</span>
<span class="hljs-comment">// panic: send on closed channel</span>
</div></code></pre>
</li>
<li>
<p>A receive from a closed channel returns the zero value immediately</p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> c = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">2</span>)
c &lt;- <span class="hljs-number">1</span>
c &lt;- <span class="hljs-number">2</span>
<span class="hljs-built_in">close</span>(c)
<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ {
    fmt.Printf(<span class="hljs-string">"%d "</span>, &lt;-c)
}
<span class="hljs-comment">// 1 2 0</span>
</div></code></pre>
</li>
</ul>
<h2 id="printing">Printing</h2>
<pre class="hljs"><code><div>fmt.Println(<span class="hljs-string">"Hello, 你好, नमस्ते, Привет, ᎣᏏᏲ"</span>) <span class="hljs-comment">// basic print, plus newline</span>
p := <span class="hljs-keyword">struct</span> { X, Y <span class="hljs-keyword">int</span> }{ <span class="hljs-number">17</span>, <span class="hljs-number">2</span> }
fmt.Println( <span class="hljs-string">"My point:"</span>, p, <span class="hljs-string">"x coord="</span>, p.X ) <span class="hljs-comment">// print structs, ints, etc</span>
s := fmt.Sprintln( <span class="hljs-string">"My point:"</span>, p, <span class="hljs-string">"x coord="</span>, p.X ) <span class="hljs-comment">// print to string variable</span>

fmt.Printf(<span class="hljs-string">"%d hex:%x bin:%b fp:%f sci:%e"</span>,<span class="hljs-number">17</span>,<span class="hljs-number">17</span>,<span class="hljs-number">17</span>,<span class="hljs-number">17.0</span>,<span class="hljs-number">17.0</span>) <span class="hljs-comment">// c-ish format</span>
s2 := fmt.Sprintf( <span class="hljs-string">"%d %f"</span>, <span class="hljs-number">17</span>, <span class="hljs-number">17.0</span> ) <span class="hljs-comment">// formatted print to string variable</span>

hellomsg := <span class="hljs-string">`
 "Hello" in Chinese is 你好 ('Ni Hao')
 "Hello" in Hindi is नमस्ते ('Namaste')
`</span> <span class="hljs-comment">// multi-line string literal, using back-tick at beginning and end</span>
</div></code></pre>
<h2 id="reflection">Reflection</h2>
<h3 id="type-switch">Type Switch</h3>
<p>A type switch is like a regular switch statement, but the cases in a type switch specify types (not values) which are compared against the type of the value held by the given interface value.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">do</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>{})</span></span> {
    <span class="hljs-keyword">switch</span> v := i.(<span class="hljs-keyword">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-keyword">int</span>:
        fmt.Printf(<span class="hljs-string">"Twice %v is %v\n"</span>, v, v*<span class="hljs-number">2</span>)
    <span class="hljs-keyword">case</span> <span class="hljs-keyword">string</span>:
        fmt.Printf(<span class="hljs-string">"%q is %v bytes long\n"</span>, v, <span class="hljs-built_in">len</span>(v))
    <span class="hljs-keyword">default</span>:
        fmt.Printf(<span class="hljs-string">"I don't know about type %T!\n"</span>, v)
    }
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    do(<span class="hljs-number">21</span>)
    do(<span class="hljs-string">"hello"</span>)
    do(<span class="hljs-literal">true</span>)
}
</div></code></pre>
<h1 id="snippets">Snippets</h1>
<h2 id="files-embedding">Files Embedding</h2>
<p>Go programs can embed static files using the <code>&quot;embed&quot;</code> package as follows:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"embed"</span>
    <span class="hljs-string">"log"</span>
    <span class="hljs-string">"net/http"</span>
)

<span class="hljs-comment">// content holds the static content (2 files) for the web server.</span>
<span class="hljs-comment">//go:embed a.txt b.txt</span>
<span class="hljs-keyword">var</span> content embed.FS

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    http.Handle(<span class="hljs-string">"/"</span>, http.FileServer(http.FS(content)))
    log.Fatal(http.ListenAndServe(<span class="hljs-string">":8080"</span>, <span class="hljs-literal">nil</span>))
}
</div></code></pre>
<p><a href="https://play.golang.org/p/pwWxdrQSrYv">Full Playground Example</a></p>
<h2 id="http-server">HTTP Server</h2>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"fmt"</span>
    <span class="hljs-string">"net/http"</span>
)

<span class="hljs-comment">// define a type for the response</span>
<span class="hljs-keyword">type</span> Hello <span class="hljs-keyword">struct</span>{}

<span class="hljs-comment">// let that type implement the ServeHTTP method (defined in interface http.Handler)</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h Hello)</span> <span class="hljs-title">ServeHTTP</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> {
    fmt.Fprint(w, <span class="hljs-string">"Hello!"</span>)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">var</span> h Hello
    http.ListenAndServe(<span class="hljs-string">"localhost:4000"</span>, h)
}

<span class="hljs-comment">// Here's the method signature of http.ServeHTTP:</span>
<span class="hljs-comment">// type Handler interface {</span>
<span class="hljs-comment">//     ServeHTTP(w http.ResponseWriter, r *http.Request)</span>
<span class="hljs-comment">// }</span>
</div></code></pre>

</body>
</html>
